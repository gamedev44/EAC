<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Encrypt-A-Chat</title>
  <style>
    body { 
      background: #111; 
      color: #0f0; 
      font-family: monospace; 
      padding: 20px; 
      margin: 0; 
      padding-bottom: 80px; /* Ensure content does not hide behind footer */
    }
    textarea, button, input { 
      width: 100%; 
      padding: 10px; 
      margin-top: 10px; 
      background: #222; 
      color: #0f0; 
      border: none; 
    }
    #chatHeader { margin-top: 20px; }
    #chatHeader button { width: auto; }
    .chat-message { margin-top: 20px; }
    .chat-text { 
      white-space: pre-wrap; 
      font-size: 1.2rem; 
      margin-bottom: 5px; 
      min-height: 1.5em; 
    }
    .timeline-canvas { 
      width: 100%; 
      height: 100px; 
      background: #000; 
      display: block; 
      border: 1px solid #0f0; 
      margin-top: 5px; 
    }
    .save-btn { 
      font-size: 0.9rem; 
      padding: 4px 8px; 
      background: #333; 
      cursor: pointer; 
      margin-top: 10px; 
      display: block; 
    }

    /* Modal styling */
    #modalOverlay {
      display: block;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 1000;
    }
    #modalContent {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #222;
      color: #0f0;
      padding: 20px;
      border: 1px solid #0f0;
      max-width: 90%;
      text-align: center;
      z-index: 1001;
    }
    #modalContent button {
      margin-top: 20px;
    }

    /* Responsive styling */
    @media only screen and (max-width: 600px) {
      body { 
        padding: 10px; 
        font-size: 0.9rem; 
      }
      textarea, button, input { 
        padding: 8px; 
        margin-top: 8px; 
      }
      .chat-text { 
        font-size: 1rem; 
      }
      .timeline-canvas { 
        height: 80px; 
      }
    }

    /* Footer styling: docked at bottom */
    footer {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      background: #111;
      color: #0f0;
      text-align: center;
      padding: 10px 0;
      border-top: 1px solid #0f0;
    }
  </style>
</head>
<body>
  <!-- Modal -->
  <div id="modalOverlay">
    <div id="modalContent">
      <p>This is an Encrypted chat app that is a faster secure form of text communications similar to morse using a system reminiscent of older dtmf codes.</p>
      <button onclick="closeModal()">Close</button>
    </div>
  </div>
  
  <header>
    <h1>
      <img src="https://cdn-icons-png.freepik.com/512/17558/17558569.png" alt="Encrypt-A-Chat Logo" style="max-width: 100px;">
    </h1>
    <h2>Encrypt-A-Chat Chat</h2>
    <h3>Inspired by Encrypt-A-Chat AI Communication Videos</h3>
  </header>

  <!-- Input area for any printable character -->
  <textarea id="textInput" placeholder="Type anything... symbols, casing, etc."></textarea>
  <button onclick="blastMessages()">ðŸ“¡ Blast</button>
  <input type="file" id="fileInput" accept=".json" />
  <button onclick="loadAndDecode()">ðŸ“¥ Load & Decode</button>

  <!-- Save full conversation button -->
  <div id="chatHeader">
    <button onclick="saveAllConvo()">ðŸ’¾ Save All</button>
  </div>

  <!-- Chat container with each message and colored timeline graph -->
  <div id="chatContainer"></div>

  <script>
    function closeModal() {
      document.getElementById("modalOverlay").style.display = "none";
    }

    // DTMF mapping for telephone digits (and *, #)
    const dtmfMapping = {
      "1": [697, 1209],
      "2": [697, 1336],
      "3": [697, 1477],
      "4": [770, 1209],
      "5": [770, 1336],
      "6": [770, 1477],
      "7": [852, 1209],
      "8": [852, 1336],
      "9": [852, 1477],
      "*": [941, 1209],
      "0": [941, 1336],
      "#": [941, 1477]
    };

    // Returns tone parameters for a given character.
    function getToneData(char) {
      if (char === " ") {
        return {
          type: "space",
          displayFreq: 0,
          barWidth: 8,
          barHeightMultiplier: 0.5
        };
      } else if (dtmfMapping[char] !== undefined) {
        const freqs = dtmfMapping[char];
        return {
          type: "dtmf",
          freqs: freqs,
          displayFreq: (freqs[0] + freqs[1]) / 2
        };
      } else {
        let charCode = char.charCodeAt(0);
        let minDisp = 1100, maxDisp = 2100;
        let dispFreq = minDisp + ((charCode - 32) / (126 - 32)) * (maxDisp - minDisp);
        return {
          type: "fax",
          start: dispFreq + 250,
          end: dispFreq - 250,
          displayFreq: dispFreq
        };
      }
    }

    // Converts a line of text into an array of tone data objects.
    function encodeLineToToneData(line) {
      const tones = [];
      for (let char of line) {
        if (char.charCodeAt(0) >= 32 && char.charCodeAt(0) <= 126) {
          tones.push(getToneData(char));
        }
      }
      return tones;
    }

    // Global conversation log
    const conversation = [];

    function blastMessages() {
      const textInput = document.getElementById("textInput");
      const lines = textInput.value.split('\n')
                      .map(l => l.trim())
                      .filter(l => l.length > 0);
      if (lines.length === 0) { alert("No message."); return; }

      const ctx = new AudioContext();
      let globalTime = ctx.currentTime;
      const duration = 0.025, gap = 0.025;
      const chatContainer = document.getElementById("chatContainer");

      lines.forEach(line => {
        const toneDataArray = encodeLineToToneData(line);
        conversation.push({ text: line, tones: toneDataArray });

        const wrapper = document.createElement("div");
        wrapper.className = "chat-message";

        const textElem = document.createElement("div");
        textElem.className = "chat-text";
        textElem.textContent = "";
        wrapper.appendChild(textElem);

        const canvas = document.createElement("canvas");
        canvas.className = "timeline-canvas";
        canvas.width = wrapper.clientWidth || 800;
        canvas.height = 100;
        const ctx2D = canvas.getContext("2d");
        wrapper.appendChild(canvas);

        const saveBtn = document.createElement("button");
        saveBtn.textContent = "ðŸ’¾ Save";
        saveBtn.className = "save-btn";
        saveBtn.onclick = () => saveSingleMessage(line, toneDataArray);
        wrapper.appendChild(saveBtn);

        chatContainer.appendChild(wrapper);

        let barX = 0;
        const defaultBarWidth = 4;
        function drawBar(tone) {
          const currentBarWidth = tone.type === "space" ? tone.barWidth : defaultBarWidth;
          if (barX + currentBarWidth > canvas.width) {
            ctx2D.clearRect(0, 0, canvas.width, canvas.height);
            barX = 0;
          }
          if (tone.type === "space") {
            const height = canvas.height * (tone.barHeightMultiplier || 0.5);
            ctx2D.fillStyle = "grey";
            ctx2D.fillRect(barX, canvas.height - height, currentBarWidth, height);
          } else {
            const height = (tone.displayFreq % 800) / 800 * canvas.height;
            const hue = tone.displayFreq % 360;
            ctx2D.fillStyle = `hsl(${hue}, 100%, 50%)`;
            ctx2D.fillRect(barX, canvas.height - height, currentBarWidth, height);
          }
          barX += currentBarWidth;
        }

        for (let i = 0; i < toneDataArray.length; i++) {
          const tone = toneDataArray[i];
          const char = line[i];
          const delay = globalTime - ctx.currentTime;

          setTimeout(() => {
            textElem.textContent += char;
            drawBar(tone);
          }, delay * 1000);

          if (tone.type === "dtmf") {
            tone.freqs.forEach(freqValue => {
              const osc = ctx.createOscillator();
              const gain = ctx.createGain();
              osc.frequency.value = freqValue;
              osc.type = 'square';
              gain.gain.value = 0.25;
              osc.connect(gain);
              gain.connect(ctx.destination);
              osc.start(globalTime);
              osc.stop(globalTime + duration);
            });
          } else if (tone.type === "fax") {
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(tone.start, globalTime);
            osc.frequency.linearRampToValueAtTime(tone.end, globalTime + duration);
            gain.gain.value = 0.25;
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.start(globalTime);
            osc.stop(globalTime + duration);
          }
          globalTime += duration + gap;
        }
      });
      textInput.value = "";
    }

    function saveSingleMessage(text, tones) {
      const blob = new Blob([JSON.stringify({ text, tones })], { type: "application/json" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = `Encrypt-A-Chat_message_${Date.now()}.json`;
      a.click();
    }

    function saveAllConvo() {
      const blob = new Blob([JSON.stringify(conversation)], { type: "application/json" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "Encrypt-A-Chat_conversation.json";
      a.click();
    }

    function loadAndDecode() {
      const fileInput = document.getElementById("fileInput");
      const file = fileInput.files[0];
      if (!file) { alert("No file selected."); return; }

      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const data = JSON.parse(e.target.result);
          const messages = Array.isArray(data) ? data : [data];
          const chatContainer = document.getElementById("chatContainer");
          chatContainer.innerHTML = "";
          conversation.length = 0;
          messages.forEach(msg => conversation.push(msg));

          const ctx = new AudioContext();
          let globalTime = ctx.currentTime;
          const duration = 0.025, gap = 0.025;

          messages.forEach(msg => {
            const line = msg.text;
            const toneDataArray = msg.tones;

            const wrapper = document.createElement("div");
            wrapper.className = "chat-message";

            const textElem = document.createElement("div");
            textElem.className = "chat-text";
            textElem.textContent = "";
            wrapper.appendChild(textElem);

            const canvas = document.createElement("canvas");
            canvas.className = "timeline-canvas";
            canvas.width = wrapper.clientWidth || 800;
            canvas.height = 100;
            const ctx2D = canvas.getContext("2d");
            wrapper.appendChild(canvas);

            const saveBtn = document.createElement("button");
            saveBtn.textContent = "ðŸ’¾ Save";
            saveBtn.className = "save-btn";
            saveBtn.onclick = () => saveSingleMessage(line, toneDataArray);
            wrapper.appendChild(saveBtn);

            chatContainer.appendChild(wrapper);

            let barX = 0;
            const defaultBarWidth = 4;
            function drawBar(tone) {
              const currentBarWidth = tone.type === "space" ? tone.barWidth : defaultBarWidth;
              if (barX + currentBarWidth > canvas.width) {
                ctx2D.clearRect(0, 0, canvas.width, canvas.height);
                barX = 0;
              }
              if (tone.type === "space") {
                const height = canvas.height * (tone.barHeightMultiplier || 0.5);
                ctx2D.fillStyle = "grey";
                ctx2D.fillRect(barX, canvas.height - height, currentBarWidth, height);
              } else {
                const height = (tone.displayFreq % 800) / 800 * canvas.height;
                const hue = tone.displayFreq % 360;
                ctx2D.fillStyle = `hsl(${hue}, 100%, 50%)`;
                ctx2D.fillRect(barX, canvas.height - height, currentBarWidth, height);
              }
              barX += currentBarWidth;
            }

            for (let i = 0; i < toneDataArray.length; i++) {
              const tone = toneDataArray[i];
              const char = line[i];
              const delay = globalTime - ctx.currentTime;

              setTimeout(() => {
                textElem.textContent += char;
                drawBar(tone);
              }, delay * 1000);

              if (tone.type === "dtmf") {
                tone.freqs.forEach(freqValue => {
                  const osc = ctx.createOscillator();
                  const gain = ctx.createGain();
                  osc.frequency.value = freqValue;
                  osc.type = 'square';
                  gain.gain.value = 0.25;
                  osc.connect(gain);
                  gain.connect(ctx.destination);
                  osc.start(globalTime);
                  osc.stop(globalTime + duration);
                });
              } else if (tone.type === "fax") {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(tone.start, globalTime);
                osc.frequency.linearRampToValueAtTime(tone.end, globalTime + duration);
                gain.gain.value = 0.25;
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(globalTime);
                osc.stop(globalTime + duration);
              }
              globalTime += duration + gap;
            }
          });
        } catch (err) {
          alert("Failed to decode.");
        }
      };
      reader.readAsText(file);
    }
  </script>
  
  <footer>
    <p>App Created By: Risk</p>
  </footer>
</body>
</html>
